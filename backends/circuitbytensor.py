import os
import time
import warnings
from collections import defaultdict, Callable
import numpy as np
from multiprocessing import Pool
import quimb as qu
# from quimb.tensor import MPS_computational_state

class CircuitByTensor:
    """generate a instance of tensor network circuit"""

    def __init__(self,
                 # p: int = 1,
                 nodes_weight: list = None,
                 edges_weight: list = None,
                 contract_opt: str = 'random-greedy',
                 is_parallel: bool = None) -> None:

        """initialize a instance of tensor network circuit:"""

        # self._p = p
        self._nodes_weight = nodes_weight
        self._edges_weight = edges_weight
        self._is_parallel = False if is_parallel is None else is_parallel
        self._opt = contract_opt

        self._subg_to_circuit = None

    def graph_to_circuit(self, params, graph, p=None, original_e=None):

        """
        transform the graph to tensor network generated by quimb
        according to the computing_framework
        Args:
            graph (nx.Graph): graph to be transformed to circuit
            params (np.array): Optimal parameters
            original_e (Optional[None, int, tuple])
        Return:
            if original_e=None, then the graph is the whole original graph generated by
            generate_weighted_graph(), so just return the circuit transformed by it

            if original_e is a int, then the subgraph is generated by node(idx = original_e
            in whole graph), so return the it's idx mapped by node_to_qubit[], and the circuit

            if original_e is a tuple, then the subgraph is generated by edge(node idx = original_e
            in whole graph), so return the it's idx mapped by node_to_qubit[] as
            tuple(mapped node_id1, mapped node_id2), and the circuit
            """

        node_to_qubit = defaultdict(int)
        node_list = list(graph.nodes)
        for i in range(len(node_list)):
            node_to_qubit[node_list[i]] = i

        N = len(graph.nodes)
        circ = qu.tensor.Circuit(N)

        # warning zwf_code
        for i in graph.nodes:
            u = node_to_qubit[i]
            circ.apply_gate('H', u)

        for k in range(p):
            for i in graph.nodes:
                u = node_to_qubit[i]
                # circ.apply_gate('H', u)
                circ.apply_gate('rz', 2 * params[2 * k] * self._nodes_weight[i], u)

            for edge in graph.edges:
                u, v = node_to_qubit[edge[0]], node_to_qubit[edge[1]]

                if u == v:
                    continue

                gamma = - params[2 * k] * self._edges_weight[edge[0], edge[1]]
                circ.apply_gate('RZZ', gamma, u, v)

            for i in graph.nodes:
                circ.apply_gate('rx', 2 * params[2 * k + 1], node_to_qubit[i])

        if original_e is None:
            return original_e, circ
        elif isinstance(original_e, int):
            return node_to_qubit[original_e], circ
        else:
            return (node_to_qubit[original_e[0]], node_to_qubit[original_e[1]]), circ

    @classmethod
    def get_tensorCircuit_expectation(cls, subc_mlt, opt):
        """
        calculate the expectation value of subc_mlt by tensor contract
        Args:
            subc_mlt (List): [[node] / [edge[0], edge[1]], circuit generated by previous item, weight]

        Returns:
            sub expectation value calculated by tensor contract
        """
        # st = time.time()
        circ = subc_mlt[2]
        nodes = subc_mlt[0]

        if isinstance(nodes, int):
            expectation = circ.local_expectation(qu.pauli('Z'), nodes, optimize=opt)
        else:
            ZZ = qu.pauli('Z') & qu.pauli('Z')
            expectation = circ.local_expectation(ZZ, nodes, optimize=opt)
        expectation = expectation.real
        # time_cost = time.time() - st
        # print('Expectation tensor expectation of subgraph generate by %s = %lf' % (str(nodes), expectation))
        # print('time_cost by tensor calculation = %0.5f' % (time.time() - st))
        return expectation * subc_mlt[1]

    def expectation_calculation(self):
        res = 0
        for key, val in self._subg_to_circuit.items():
            # print("draw the subcircuit generated by nodes ", key)
            # val[1].draw(output='mpl', interactive=True)
            res += self.get_tensorCircuit_expectation(val, self._opt)
        print("Expectation value of original graph (tensor calculation) is: ", res)

        # exp_sam_np.append(res)
        return res

    def expectation_calculation_parallel(self):
        circ_res = []
        pool = Pool(os.cpu_count())
        circ_res.append(pool.map(self.get_tensorCircuit_expectation, list(self._subg_to_circuit.values())))
        pool.terminate()   # pool.close()
        pool.join()

        res = sum(circ_res[0])

        print("Expectation value of original graph (tensor calculation) is: ", res)
        return res
